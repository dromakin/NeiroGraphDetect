# Оцифровка графов
Автор: Ромакин Д.В.

Привет всем читателям Habrahabr!

В этой статье я хочу поделиться с вами своим первым проектом, связанным с компьютерным зрением. Данная тема "на пальцах" освещается  плохо.

**В проекте затрагиваются темы:**
- обработка изображения с помощью библиотеки OpenCV;
- сверточные нейронные сети;
- каскады Хаара;
- сравнение различных алгоритмов распознавания из библиотеки OpenCV;
- самописный алгоритм оцифровики графов.

### Результаты на текущей стадии
На вход подается изображение графа, на выходе получаем матрицу смежности.

Дальше используем матрицу чтобы нарисовать граф с помощью библиотеки (!!!)
Граф нарисованный на доске (слева), результат - справа

![](./photo/58.png)
![](./photo/59.png)

- на бумаге (слева), результат - справа

![](./photo/61.png)

### Визуализация работы
![](./photo/result.gif)


## Оглавление
  * Описание работы системы
  * Подготовка данных
    - Фильтрация с помощью сверточных ядер
    - Итоговая программа предобработки изображения
  * Поиск вершин графа
    - Каскады Хаара
      + Почему каскады Хаара?
      + Подготовка данных
      + Обучение признаков Хаара
      + Выбор обученной модели Хаара
    - Фильтр СНС
    - Дополнительный фильтр пересечений
  * Распознавание линий
    - Поиск начал линий
      + Поиск начал линий с помощью Каскадов Хаара
      + Поиск начал линий с помощью HoughCirclesP
    - Поиск пересечений линий с помощью Каскадов Хаара
    - Tracker
      + Поиск начал линий
      + Движение Tracker
        * Условие соединенности вершин
        * Как движется Tracker
        * Что происходит при различных выходах в пункте 4
      + Tracker Shoot
      + Основные проблемы и их решения
  * Выводы
  * Литература


**Описание работы системы**
=================
![](./photo/0.png)

Программа разбита в несколько этапов:

1.  На вход поступает изображение и
    запускается скрипт для подготовки данных.  (удаление шумов и инвертирование
    цветов в 1 канал).

2.  VertexSearch: На изображении с помощью каскадов Хаара ищем вершины графа,
    затем запускаем фильтрацию в 2 этапа (СНС и дополнительный
    алгоритмический фильтр), сохраняем полученные данные файл для
    следующего этапа.

3.  EdgeSearch: Определяем начало движения Tracker у каждой вершины графа с
    помощью дополнительных прямоугольников.

4.  EdgeSearch: Запускаем Tracker для определения какие вершины соединены.

5.  Составляется удобный формат для дальнейшей визуализации.

**Подготовка данных**
=================

После анализа входных изображений пришлось использовать фильтр Гаусса и перевод в один канал.

Изображение подается на вход с префиксом green/white:

1.  Если изображение больше, чем 900 пикселей в ширине или высоте, то
    уменьшаем размер до 900x900 (размер на высоте или ширине должен быть
    меньше или равен 900). Если изображение не квадратное, то сохраняя
    пропорции уменьшаем самую большую сторону до 900.

2.  Green - изображение с доски. Этапы: переводим в 1 канал, убираем
    шумы и инвертируем цвета (чтобы выделить черным контур графа)

3.  White - изображение с листка бумаги. Этапы: переводим в 1 канал.

Код:
```python
def preprocessing(image, type=None, save=False):
    img = image.copy()
    height, width, depth = img.shape

    if ((height > 900) | (width > 900)):
        img = module.resizeImage(img, width=900, height=900, save=True)

    if ((type == 'Green') | (type == 'green')):
        # filtering
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        kernel_size = 5
        blur_gray = cv2.GaussianBlur(gray, (kernel_size, kernel_size), 2)
        imgbit = cv2.bitwise_not(blur_gray)
        if save == True:
            module.saveImage(path + 'preprocessing.jpg', imgbit)

        return imgbit
    else:
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        if save == True:
            module.saveImage(path + 'preprocessing.jpg', gray)

        return gray
```

**Поиск вершин графа**
======================

Обработанное изображение подается на вход алгоритму, который состоит из несколько шагов:

1.  [Каскады Хаара](https://habr.com/ru/company/recognitor/blog/228195/).

2.  Фильтр, реализованный с помощью сверточной нейронной сети.

3.  Алгоритмический фильтр.

Рассмотрим каждый из этапов более детально.

## **Каскады Хаара**

### Почему каскады Хаара?

Для поиска окружностей рассматривалаись 4 алгоритма:
1.  Simple Blob Detector ([example](https://www.learnopencv.com/blob-detection-using-opencv-python-c/), [documentation](https://docs.opencv.org/3.4.3/d0/d7a/classcv_1_1SimpleBlobDetector.html))
2.  MSER Blob Detector ([example](http://qaru.site/questions/2443082/merge-mser-detected-objetcs-opencv-python), [documentation](https://docs.opencv.org/2.4/modules/features2d/doc/feature_detection_and_description.html?highlight=mser))
3.  Hough Circles ([example](https://www.pyimagesearch.com/2014/07/21/detecting-circles-images-using-opencv-hough-circles/), [documentation](https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_houghcircles/py_houghcircles.html))
4. Каскады Хаара

Первые 2 не подошли из-за маленького числа распознанных вершин при тестировании,
а последний алгоритм (3) может конкурировать с каскадами,
но ему требуется правильные коэффициенты для каждого изображения.

Про каскады Хаара написано много статей и другой литературы. При желании можно найти описание этого алгоритма. Моя (эта, данная!!!) статья не будет углубляться в эту тему.

### Подготовка данных

Для успешного обучения потребуется большое количество «отрицательных» и «положительных» образцов. Для более удобной разметки изображений используется разработанная программа, которая позволяет получить изображения вершин графа, путем выделения нужной области в ходе работы программы. При малом количестве изображений можно сгенерировать дополнительные наборы данных путем поворота их на определенный угол, который задается перед запуском, или на произвольный угол (от 0 до 180 градусов). Что и было проделано.

### Обучение признаков Хаара
Информацию о том как обучить каскады Хаара локально у себя на компьюторе можно найти [тут](https://habr.com/ru/post/208092/), [тут](https://docs.opencv.org/3.3.0/dc/d88/tutorial_traincascade.html) и [тут](https://medium.com/@a5730051/train-dataset-to-xml-file-for-cascade-classifier-opencv-43a692b74bfe).

Обучение различных моделей Хаара производилось на облачном вычислительном ресурсе: Google Cloud Platform, на виртуальной машине Ubuntu.

Скрипт для запуска обучение каскадов можно посмотреть в репозитории (!!! ссылка на скрипт)

Каскады Хаара обучаются очень долго из-за того, что обучаются на CPU. Те кто захочет повторить мой опыт - обязательно используйте GPU!

### Выбор обученной модели Хаара

Код для тестирования каскада Хаара:

```python
def haartest(image):
    # This is the cascade we just made. Call what you want
    cascade30 = cv2.CascadeClassifier('./models/haar/haar_2020_2/cascade.xml')
    img = cv2.imread(image)
    if img is None:
        exit(0)
    img_c = img.copy()
    # filters
    gray = cv2.cvtColor(img_c, cv2.COLOR_BGR2GRAY)
    # gaus = cv2.GaussianBlur(gray, (5, 5), 2)
    vertex30 = cascade30.detectMultiScale(gray)
    it = 0
    # get rectangle
    for (x, y, w, h) in vertex30:
        crop_img = img[y:y + h, x:x + w]
        label = neural_network_2828(crop_img)

        # put text
        if (label[0] == "Vertex"):
            cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 255), 2)
            font = cv2.FONT_HERSHEY_SIMPLEX
            cv2.putText(img, 'V'+label[2], (x - 2, y - 2), font, 0.5, (255, 0, 255), 1, cv2.LINE_AA)
        else:
            cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)
            font = cv2.FONT_HERSHEY_SIMPLEX
            cv2.putText(img, 'NV'+label[2], (x - 2, y - 2), font, 0.5, (0, 255, 0), 1, cv2.LINE_AA)
        it += 1

    # save image
    x = image.split("/")
    print(x[-1])
    path = './results/result_Haar_NN_test/'
    # cv2.imshow('img',img)
    cv2.imwrite(path + x[-1], img)
```

#### Как выбирается лучший каскад?
!!!!! ТУТ ничего не понял !!!!

Проанализируем каждый каскад в целом с помощью диаграмм:
![](./photo/26.png)

!!! что на осях !!!

Видно, что минимальное число ложных срабатываний (число нераспознанных вершин)
имеет каскад Хаара 20x20 2 типа.

Отсюда делаем вывод - будем использовать - Хаар 20x20 2 типа:

![](./photo/27.png)

**Фильтр сверточной нейронной сети**
--------------
Из-за того, что каскады Хаара иногда выделяют пересечения линий, похожие на вершину графа, то данные случаи необходимо свести к минимуму с помощью сверточной нейронной сети. Задача сверточной нейронной сети (СНС) - классификация вершин.

О том как работает свертка в изображении можно найти в моем репозитории в ветке Steps-of-project: [Ccылка](https://github.com/Dmitriy1594/NeiroGraphDetect/tree/Steps-of-project/Image%20processing/Convolutional-Layers)

Подробнее о том, что такое сверточная нейронная сеть - [ссылка](https://habr.com/ru/post/348000/)

#### Архитектура
**За основу архитектуры нейронной сети была
взята сверточная нейронная сеть LeNet5:**
![](./photo/28.png)

**Так как вершина графа является кругом, то для измененной архитектуры СНС
число features maps на каждом этапе свертки примерно такое же, как и для
различных букв алфавита, которые используется для обучения нейронной
сети на изображении.**

**В результате многочисленных экспериментов
была найдена оптимальная архитектура СНС:**
![](./photo/29.png)

На выходе два нейрона, которые дают вероятностную оценку вершина или не вершина.

Код для тестирования СНС:
```python
def neural_network(image, dirtocnn):
    orig = image
    # pre-process the image for classification
    image = cv2.resize(image, (28, 28))
    image = image.astype("float") / 255.0
    image = img_to_array(image)
    image = np.expand_dims(image, axis=0)
    print("[INFO] loading network...")
    # load model
    model = load_model('./../models/neural_networks/' + dirtocnn)
    vertex = 0
    notVertex = 0
    print(dirtocnn.split('_')[0])
    # classify the input image
    if dirtocnn.split('_')[0] == 'not':
        (vertex, notVertex) = model.predict(image)[0]
    else:
        (notVertex, vertex) = model.predict(image)[0]

    label = "Vertex" if vertex > notVertex else "Not Vertex"
    proba = vertex if vertex > notVertex else notVertex
    labelprob = "{}: {:.2f}%".format(label, proba * 100)
    return (label, labelprob, str(float("{0:.2f}".format(proba * 100))))
```

#### Статистика по СНС:
На рисунке изображено !!! что именно !!!:
![](./photo/30.png)

#### Лучший результат:
![](./photo/31.png)

Было использовано 15 фото для анализа фильтра, основанный на нейронной сети. Общее затраченное время на анализ моделей: 4,5 часа. Фильтрация, основанная на нейронной сети - дорогостоящая операция, но эффективная.

### Дополнительный фильтр пересечений

**Данный фильтр позволяет избавится от некоторых случаев пересечения:**
![](./photo/32.png)

**Слева** - пересечение, которое поймал алгоритм, а **справа** - результат.

Все подобные случаи пересечения учитываются при выполнения работы.

### Результаты подготовки данных

Каскад Хаара | Фильтр СНС | Результат
--- | --- | ---
![](./photo/haar_1.jpg)  | ![](./photo/haar_cnn_1.jpg)   |  ![](./photo/vertex_predict_1.jpg)
![](./photo/haar_2.jpg)  | ![](./photo/haar_cnn_2.jpg)   |  ![](./photo/vertex_predict_2.jpg)

## Определение граней графа

Для того чтобы определить линию, необходимо знать:

-   Точку начала линии

-   Точку пересечения линии с другими


!!! ТАК МНОГО ИНФОРМАЦИИ ЧТОБЫ ПОТОМ СКАЗАТЬ ЧТО ЭТО НЕ ВЗЛЕТЕЛО?! ПОЩАДТЕ читателей!!!
##### Поиск точек начала граней с помощью Каскадов Хаара

Изначально предлагалось использовать каскады для поиска начал линий.
Но в этот метод обладает недостатком:
любой шум, который есть на изображении может стать областью началом линии. По этой причине пришлось отказаться от
данной идеи.

##### Поиск точек пересечения с помощью Каскадов Хаара
Использование каскадов не подходит из-за малой точности и большой
погрешности. Некоторый процент распознанных точек начал линий и точек
пересечений является ложным срабатыванием, поэтому точность еще ниже,
чем предполагалось.

##### Поиск начал линий с помощью Hough Lines
Используя алгоритм HoughLinesP из библиотеки OpenCV, удалось достичь хорошего результата, но у него есть один большой минус, который не позволил его использовать в данной задаче. !!! какой !!!.

#### **Этапы алгоритма:**

1.  С помощью алгоритма Хаара и дополнительных фильтров определяем, где находятся вершины.

2.  Далее расширяем квадрат области с вершиной на среднее значение, вычисленное по среднему значению длины и ширины для данной области.

3.  Точки линий, обнаруженные алгоритмом HoughLinesP, которые находятсямежду квадратной областью Хаара и дополнительного квадрата, являются точками начала линий.

#### **Результат поиска начал линий:**
![](./photo/37.png)

##### Сращивание маленьких линий с помощью Hough Lines
На основе алгоритма HoughLinesP была создана программа, которая позволяет
разбить линию после обработки алгоритмом Canny из OpenCV на маленькие
линии, чтобы потом срастить линии в одну.

Этапы программы на примере:

| 1) Обработанное изображение с доски     |       2) Алгоритм Canny |
| ------------- |:-------------:|
| ![](./photo/38.png)      |    ![](./photo/39.png) |
| 3)  Алгоритм HoughLinesP    |   4)  Алгоритм склеивания линий |
| ![](./photo/40.png)  |   ![](./photo/41.png) |

#### **Итог**
Данный метод безусловно эффективен для конкретного изображения, но для любого другого необходимо подбирать коэффициенты для склеивания линий.
Именно по этой причине эта программа не подошла.

### **Вывод**
Ни один из предложенных алгоритмов не подходит, поэтому был создан свой
алгоритм Tracker, который пробегается по пикселям линии. По этой причине
поиск начал линий было решено как пересечения вспомогательных квадратов
на основе размеров квадрата Хаара с пикселями линии графа - линий
движения умного ползунка (Tracker).

### Tracker
Поиск начал линий
-----------------

#### Этапы работы программы:

!!! НЕ НАДО ТАБЛИЦЫ !!! ЛУчше линейно вниз !!!

| 1) Обработанное изображение | 2) Алгоритм Canny |
| ------------- |:-------------:|
| ![](./photo/42.png) | ![](./photo/43.png) |
| 3) С помощью свертки соединяем 2 линии после алгоритма Canny  |  4) Уменьшаем размер линии до малого числа пискселей, чтобы не было разрыва |
| ![](./photo/44.png) | ![](./photo/45.png) |
| 5) То множество пикселей, которое попало в область дополнительных прямоугольников - удаляется  |  6) Белая часть - это множество точек пересечения, поэтому выбираем центральную точку пересечения для каждой области |
| ![](./photo/46.png) | ![](./photo/47.png) |
| 7) Получаем точки начал линий  |  8) После удаления в 5 пукте находим линии движения Tracker ("Умного ползунка") |
| ![](./photo/48.png) | ![](./photo/49.png) |

С помощью данного алгоритма мы можем «пройтись по линиям» графа.

Точка начала линий определяется с помощью дополнительных квадратов на
основе выделенной области Хаара.

#### Результат:
![](./photo/50.png)

Движение Tracker
----------------

### Условие соединенности вершин
Для того, чтобы подтвердить, что линия принадлежит данным двум вершинам, необходимо, чтобы Tracker прошел от одной точки к другой, хотя бы один раз.

### Как двигается Tracker?
Движение основано на пересечении окружности с линией «дорогой» Tracker.

![](./photo/52.png)

#### Алгоритм:
1.	На точке начала линии, рисуется красная окружность
2.	Находится ее пересечение с пикселями линии (дороги) Tracker
3.	Множество точек пересечения приводится к одной точке, в которой рисуется новая окружность (приведение к одной точке такое же как и у поиска начал линий)
4.	Циклически выполняем 2-3, до тех пор, пока не встретим:
  - Другую точку начала линии
  - Конец линии или окончание дороги


  Движение Tracker | Траектория движения Tracker
  ------------ | -------------
  ![](./photo/53.png) | ![](./photo/54.png)

### Что происходит при различных выходах в пункте 4?
Включается прострел Tracker, который проверяет попадает ли линия в центр главного (красного) прямоугольника, который является границами распознанной вершины, используя координаты последних двух окружностей для построения прострела. Более подробно в главе про Tracker Shoot.

### Tracker Shoot
Данный алгоритм начинает работать после встречи одно из условий 4 пункта алгоритма движения Tracker.
Рассмотрим работу на примере.

![](./photo/55.png)

Сверху на картинке изображен прострел для потверждения того, что линия приходит к вершине, а не уходит в сторону. Для прострела используется 2 координаты центра последних окружностей для построения линии и вычисления коэффициента k и b для рассчета.
- **Белая окружность** – точка начала линии.
- **Красная окружность** – последний шаг Tracker.
- При отсутствии белой окружности, т.е. точки начала линии, используется координаты 2 последних красных окружностей.

![](./photo/56.png)

**Функция прямой: y=kx+b**

**Искомый коэффициент: k=(y-b)/x**

Используя координаты крайних точек главной области вершины (красный прямоугольник) и координату начала линии (в случае ее отсутсвия – последнюю красную окружность) определяем границы значения коэффициента k для прямой, которая должна попасть в область, где находится вершина.

Используя координаты центров белого и красного круга определяем функцию прямой, а затем искомый коэффициент.

Если коэффициент находится в допустимой области, то картинка будет такая же как слева.

### Основные проблемы и их решения
1.	При разрыве линии алгоритм движения Tracker может остановиться, т.к. попадет в провал точка пересечения окружности с траекторией Tracker.
  - [x] Решение – сделать динамическое расширение окружности на каждом шаге Tracker
2.	При пересечении линий алгоритм не работает, т.к. имеет много пересечений с траекторией Tracker
  - [x] Решение – сделать динамическое расширение окружности на каждом шаге Tracker
3.	Определение точек начала линии иногда дает плохой результат, если какая-либо линия проходит рядом с областью вершины (пример ниже).
  - [x] Решение – двойная верификация вершин, т.е. движение Tracker производится сначала в одну сторону, а потом в другую.

#### **Пример проблемы:**
![](./photo/57.png)

Примеры
==========

Original image | Preprocessing | Vertex Search | Find Start | Tracker | Result
--- | --- | --- | --- | --- | ---
![](./photo/ex1_0.jpg) | ![](./photo/ex1_1.gif) | ![](./photo/ex1_2.gif) | ![](./photo/ex1_3.gif) | ![](./photo/ex1_4.gif) | ![](./photo/ex1_5.jpg)
![](./photo/ex2_0.jpg) | ![](./photo/ex2_1.gif) | ![](./photo/ex2_2.gif) | ![](./photo/ex2_3.gif) | ![](./photo/ex2_4.gif) | ![](./photo/ex2_5.jpg)
![](./photo/ex3_0.jpg) | ![](./photo/ex3_1.gif) | ![](./photo/ex3_2.gif) | ![](./photo/ex3_3.gif) | ![](./photo/ex3_4.gif) | ![](./photo/ex3_5.jpg)
![](./photo/ex4_0.jpg) | ![](./photo/ex4_1.gif) | ![](./photo/ex4_2.gif) | ![](./photo/ex4_3.gif) | ![](./photo/ex4_4.gif) | ![](./photo/ex4_5.jpg)

Original image | Preprocessing | Vertex Search with action | Find Start | Tracker | Result
--- | --- | --- | --- | --- | ---
![](./photo/ex5_0.jpg) | ![](./photo/ex5_1.gif) | ![](./photo/ex5_2.gif) | ![](./photo/ex5_3.gif) | ![](./photo/ex5_4.gif) | ![](./photo/ex5_5.jpg)


### Начну сразу с результатов
Данная работа посвящалась оцифровке графов, если граф без пересечений и без весов, то задача выполнена, иначе – есть над чем работать.

Литература
==========
1.	https://www.pyimagesearch.com/2017/08/21/deep-learning-with-opencv/
2.	https://habr.com/ru/post/309508/
3.	https://www.asozykin.ru/courses/nnpython-intro
4.	Курсы по нейронным сетям от Deep Learning Course при МФТИ
